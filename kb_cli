#!/usr/bin/env python
"""Script to generate keyboard plates and cases from KLE data.

By default this reads the data on stdin. You can also use --file to pass data
in through a file.
"""
import argparse
import builder
import hashlib
import hjson
import logging
import sys
from time import time
import config


logging.basicConfig()

# Parse our command line args
parser = argparse.ArgumentParser()
parser.add_argument('-f', '--file', help='File containing the KLE data.')
parser.add_argument('-n', '--name', help='Output file basename (Default: generate a hash or use -f)')
parser.add_argument('--switch', help='Switch type: mx, (*)alpsmx, mx-open, alps')
parser.add_argument('--stab', help='Stabilizer type: cherry, costar, (*)cherry-costar, alps, matias')
parser.add_argument('--case', help='Case type: (*)none, poker, sandwich')
parser.add_argument('--case-holes', default=8, type=int, help='Number of holes in the case (Default: 8)')
parser.add_argument('--hole-diameter', default=5, type=float, help='Case hole size in mm (Default: 5)')
parser.add_argument('--usb-offset', default=0, type=float, help='Offset from center for USB connector')
parser.add_argument('--usb-inner-width', default=10, type=float, help='Width for the USB connector cutout closest to the PCB')
parser.add_argument('--usb-outer-width', default=14, type=float, help='Width for the USB connector cutout furthest from the PCB')
parser.add_argument('--usb-height', default=7.5, type=float, help='How far down the bottom plate to cut to allow for the USB connector.')
parser.add_argument('--reinforcing', default=False, action='store_true', help='Add the reinforcing plate to a non-case layout.')
parser.add_argument('--height', default=6, type=float, help='Amount to pad the height (Default: 6)')
parser.add_argument('--width', default=6, type=float, help='Amount to pad the width (Default: 6)')
parser.add_argument('--hole', default=[], action='append', help='Add a hole at X,Y,Diameter')
parser.add_argument('--pcb-height', default=0, type=float, help='Amount to pad the height of the cutout to accommodate a pcb (Default: 0)')
parser.add_argument('--pcb-width', default=0, type=float, help='Amount to pad the width of the cutout to accommodate a pcb (Default: 0)')
parser.add_argument('--corners', default=0, type=float, help='Radius for corners, 0 to disable (Default: 0)')
parser.add_argument('--corner-type', default='round', type=str, help='What kind of corners to make (*round, beveled)')
parser.add_argument('--thickness', default=0, type=float, help='Plate thickness, 0 to disable (Default: 0)')
parser.add_argument('--kerf', default=0, type=float, help='Kerf, 0 to disable (Default: 0)')
parser.add_argument('--add-format', default=[], action='append', help='Add a format to be exported (brp, stp, stl)')
parser.add_argument('--output-dir', type=str, help='What directory to output files to (Default: %s)' % config.app['export'])
parser.add_argument('--oversize', default=[], action='append', help='Make a layer larger than the other layers')
parser.add_argument('--oversize-distance', type=int, default=4, help='How much larger an oversized layer is.')
args = parser.parse_args()

# Make sure the corners are specified correctly
if args.corner_type not in ('round', 'beveled'):
    logging.error('Incorrect corner type: %s', args.corner_type)
    exit(1)
else:
    if args.corner_type == 'round':
        args.corner_type = 0
    elif args.corner_type == 'beveled':
        args.corner_type = 1

# Figure out what kind of switch it is
if args.switch:
    if args.switch == 'mx':
        args.switch = 0
    elif args.switch == 'alpsmx':
        args.switch = 1
    elif args.switch == 'mx-open':
        args.switch = 2
    elif args.switch == 'alps':
        args.switch = 4
    elif args.switch in ('1', '2', '3', '4'):
        args.switch = int(args.switch)
    else:
        logging.error('Unknown switch type: %s', args.switch)
        exit(1)
else:
    args.switch = 1

# Figure out what kind of stab it is
if args.stab:
    if args.stab == 'cherry':
        args.stab = 1
    elif args.stab == 'costar':
        args.stab = 2
    elif args.stab == 'cherry-costar':
        args.stab = 0
    elif args.stab == 'matias':
        args.stab = 3
    elif args.stab == 'alps':
        args.stab = 4
    elif args.stab in ('1', '2', '3', '4', '5'):
        args.stab = int(args.stab)
    else:
        logging.error('Unknown stab type: %s', args.stab)
        exit(1)
else:
    args.stab = 3

# Figure out what kind of case it is
if args.case:
    if args.case == 'none':
        args.case = ''
    elif args.case not in ('none', 'poker', 'sandwich'):
        logging.error('Unknown case type: %s', args.case)
        exit(1)

# Add any designated holes
holes = []
if args.hole:
    for hole in args.hole:
        x, y, diameter = hole.split(',')  # Make sure it's in the right format
        holes.append((float(x), float(y), float(diameter)))

# Determine what formats to support
for format in args.add_format:
    config.app['formats'].append(format)

# Set our output directory
if args.output_dir:
    config.app['export'] = args.output_dir

# MAIN
if __name__ == '__main__':
    if args.file:
        layout = open(args.file).read()
    else:
        if sys.stdin.isatty():
            print '*** Paste the KLE data here and press Ctrl-D to process it:'
        layout = sys.stdin.read()

    layout = '{"layout": [' + layout + ']}'
    layout = hjson.loads(layout)['layout']
    data = {
        'switch_type': args.switch,
        'stab_type': args.stab,
        'case_type': args.case,
        'mount_holes_num': args.case_holes,
        'mount_holes_size': args.hole_diameter,
        'width_padding': args.width,
        'height_padding': args.height,
        'pcb_width_padding': args.pcb_width,
        'pcb_height_padding': args.pcb_height,
        'corners': args.corners,
        'corner_type': args.corner_type,
        'thickness': args.thickness,
        'kerf': args.kerf,
        'reinforcing': args.reinforcing,
        'usb_inner_width': args.usb_inner_width,
        'usb_outer_width': args.usb_outer_width,
        'usb_height': args.usb_height,
        'usb_offset': args.usb_offset,
        'keyboard_layout': layout,
        'oversize': args.oversize,
        'oversize_distance': args.oversize_distance
    }

    # Figure out the export file name
    if args.name:
        export_basename = args.name
    elif args.file:
        export_basename = args.file
    else:
        export_basename = hjson.dumps(data, sort_keys=True)
        export_basename = hashlib.sha1(export_basename).hexdigest()
    data['export_basename'] = export_basename

    # Remove default options
    if args.case == '':
        del(data['mount_holes_size'])
        del(data['mount_holes_num'])

    if args.height == 0:
        del(data['height_padding'])

    if args.width == 0:
        del(data['width_padding'])

    if args.thickness == 0:
        del(data['thickness'])

    if args.corners == 0:
        del(data['corners'])

    if args.kerf == 0:
        del(data['kerf'])

    # Add any holes
    if holes:
        data['holes'] = holes

    # Build the plate
    build_start = time()
    logging.info("Processing %s", (data['export_basename']))
    cad = builder.build(data)
    logging.info("Finished %s", (data['export_basename']))
    logging.info("Processing took {0:.2f} seconds".format(time()-build_start))

    # Display info about the plates
    print '**** Overall plate size: %s x %s mm' % (cad['width'], cad['height'])

    for plate in cad['plates']:
        print '*** Files exported for plate', plate
        for file in cad['exports'][plate]:
            print '*', file['url'][1:]
